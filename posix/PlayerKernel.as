// Copyright (c) 2013 Adobe Systems Inc

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package com.adobe.flascc.kernel {

    import flash.utils.ByteArray;
    import flash.utils.Endian;
    import flash.utils.IDataInput;

    import com.adobe.flascc.CModule;
    import com.adobe.flascc.vfs.CheckPath;
    import com.adobe.flascc.vfs.FileHandle;
    import com.adobe.flascc.vfs.PathUtils;
    import C_Run.ram;
    import C_Run.workerClass;
    import C_Run.yield;

    CONFIG::actual
    {
        // IKernel.as is autogenerated and contains the BSD syscall interface
        include 'IKernel.as'
    }

    /**
    * This helper class contains constant values defined in the libc headers.
    */
    public class KernelConstants
    {
        // Values for open's flags argument
        public static const O_RDONLY:int =     0x0000;
        public static const O_WRONLY:int =     0x0001;
        public static const O_RDWR:int =       0x0002;
        public static const O_ACCMODE:int =    0x0003;
        public static const O_NONBLOCK:int =   0x0004;
        public static const O_APPEND:int =     0x0008;
        public static const O_CREAT:int =      0x0200;
        public static const O_TRUNC:int =      0x0400;
        public static const O_EXCL:int =       0x0800;
        public static const O_SHLOCK:int =     0x0010;
        public static const O_EXLOCK:int =     0x0020;
        public static const O_NOFOLLOW:int =   0x0100;
        public static const O_DIRECT:int =     0x00010000;
        public static const O_SYNC:int =       0x0080;
        public static const O_FSYNC:int =      0x0080;

        // Status information for stat's st_mode
        public static const S_IFIFO:int =       0x1000;
        public static const S_IFCHR:int =       0x2000;
        public static const S_IFDIR:int =       0x4000;
        public static const S_IFBLK:int =       0x6000;
        public static const S_IFREG:int =       0x8000;
        public static const S_IFLNK:int =       0xA000;
        public static const S_IFSOCK:int =      0xC000;
        
        // whence values for lseek
        public static const SEEK_SET:int =  0;
        public static const SEEK_CUR:int =  1;
        public static const SEEK_END:int =  2;

        // File types for getDirectoryEntries
        public static const DT_UNKNOWN:int =    0;
        public static const DT_FIFO:int =       1;
        public static const DT_CHR:int =        2;
        public static const DT_DIR:int =        4;
        public static const DT_BLK:int =        6;
        public static const DT_REG:int =        8;
        public static const DT_LNK:int =        10;
        public static const DT_SOCK:int =       12;
        public static const DT_WHT:int =        14;
        
        // errno values
        public static const EPERM:int =    1;
        public static const ENOENT:int =   2;
        public static const ESRCH:int =    3;
        public static const EINTR:int =    4;
        public static const EIO:int =      5;
        public static const ENXIO:int =    6;
        public static const E2BIG:int =    7;
        public static const ENOEXEC:int =  8;
        public static const EBADF:int =    9;
        public static const ECHILD:int =   10;
        public static const EDEADLK:int =  11;
        public static const ENOMEM:int =   12;
        public static const EACCESS:int =  13;
        public static const EFAULT:int =   14;
        public static const ENOTBLK:int =  15;
        public static const EBUSY:int =    16;
        public static const EEXIST:int =   17;
        public static const EXDEV:int =    18;
        public static const ENODEV:int =   19;
        public static const ENOTDIR:int =  20;
        public static const EISDIR:int =   21;
        public static const EINVAL:int =   22;
        public static const ENFILE:int =   23;
        public static const EMFILE:int =   24;
        public static const ENOTTY:int =   25;
        public static const ETXBSY:int =   26;
        public static const EFBIG:int =    27;
        public static const ENOSPC:int =   28;
        public static const ESPIPE:int =   29;
        public static const EROFS:int =    30;
        public static const EMLINK:int =   31;
        public static const EPIPE:int =    32;
        public static const ENOTEMPTY:int= 66;
        public static const ENOSYS:int=    78;
        public static const EOVERFLOW:int= 84;

        // fcntl commands
        public static const F_DUPFD:int =  0;
    }

    /**
    * This is the default implementation of the Posix interface. Extending and
    * overriding methods in this class allow you to customize the handling
    * of the basic syscalls on top of which libc operates.
    */
    public class PlayerKernel implements IKernel {

        /**
        * Construct the default IKernel implementation used by flascc. If an alternate
        * implementation has not already been assigned to the CModule.kernel property,
        * then this class will be constructed on first access.
        */
        public function PlayerKernel() {
        }

        private function getFileHandleFromFileDescriptor(fd:int, errnoPtr:int):FileHandle {
            var fdentry:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)
            if (!fdentry) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
            }
            return fdentry
        }

        private function create(path:String):FileHandle {
            CModule.vfs.addFile(path, new ByteArray)
            return CModule.vfs.getFileHandleFromPath(path)
        }

        private function readNullTerminatedStr(ptr:int):String {
            var pathlen:uint
            for (pathlen = 0; CModule.read8(ptr + pathlen) != 0; pathlen++) {}
            return CModule.readString(ptr, pathlen)
        }

        /**
        */
        public function read(fd:int, buf:int, nbyte:int, errnoPtr:int):int {
            var fdentry:FileHandle = getFileHandleFromFileDescriptor(fd, errnoPtr)
            if (!fdentry) {
                return -1
            }

            if (!fdentry.readable) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
                return -1
            }

            if (fdentry.isDirectory) {
                CModule.write32(errnoPtr, KernelConstants.EISDIR)
                return -1
            }

            if (fdentry.callback) {
                return fdentry.callback.read(fd, buf, nbyte, errnoPtr)
            }
            
            fdentry.bytes.position = fdentry.position
            var nbytes:uint = Math.min(nbyte, fdentry.bytes.bytesAvailable)

            if (nbytes > 0)
            {
                CModule.writeBytes(buf, nbytes, fdentry.bytes)
            }

            fdentry.position = fdentry.bytes.position
            return nbytes
        }

        /**
        */
        public function write(fd:int, buf:int, nbyte:int, errnoPtr:int):int {
            var fdentry:FileHandle = getFileHandleFromFileDescriptor(fd, errnoPtr)
            if (!fdentry) {
                return -1
            }

            if (fdentry.callback) {
                return fdentry.callback.write(fd, buf, nbyte, errnoPtr)
            }
           
            if (fdentry.writeable) {
                fdentry.bytes.position = (fdentry.appending) ? 
                    fdentry.bytes.length : fdentry.position
                for (var i:uint = 0; i < nbyte; i++) {
                    fdentry.bytes.writeByte(CModule.read8(buf + i))
                }
                fdentry.position = fdentry.bytes.position
            } else {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
                nbyte = -1
            }

            return nbyte
        }

        private function iov(fd:int, vecs:int, veccnt:int, 
                                errnoPtr:int, f:Function):int {
            var res:int = 0
            for (var i:uint = 0; i < veccnt; i++) {
                var ret:int = f(fd, CModule.read32(vecs), 
                                    CModule.read32(vecs + 4),
                                    errnoPtr)
                if (ret < 0) {
                    return -1
                }
                res += ret
                vecs += 8
            }
            return res
        }

        /**
        */
        public function writev(fd:int, vecs:int, veccnt:int, errnoPtr:int):int {
            return iov(fd, vecs, veccnt, errnoPtr, write)
        }

        /**
        */
        public function readv(fd:int, vecs:int, veccnt:int, errnoPtr:int):int {
            return iov(fd, vecs, veccnt, errnoPtr, read)
        }

        /**
        */
        public function open(path:int, flags:int, mode:int, errnoPtr:int):int {
            var pathstr:String = readNullTerminatedStr(path)
            var fileentry:FileHandle = CModule.vfs.getFileHandleFromPath(pathstr)
            var creat:Boolean = Boolean(flags & KernelConstants.O_CREAT)
            var creatEx:Boolean = creat && flags & KernelConstants.O_EXCL
            var ret:int = -1
            var res:String

            if (!pathstr.length) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            }

            if (!fileentry && creat) {
                res = CModule.vfs.checkPath(pathstr)

                if (res == CheckPath.PATH_COMPONENT_DOES_NOT_EXIST) {
                    CModule.write32(errnoPtr, KernelConstants.ENOENT)
                    return -1
                } else if (res == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                    CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                    return -1
                }
                var dirname:String = PathUtils.getDirectory(pathstr)
                var direntry:FileHandle = CModule.vfs.getFileHandleFromPath(dirname)
                if (!direntry.writeable) {
                    CModule.write32(errnoPtr, KernelConstants.EROFS)
                    return -1
                }
                
                fileentry = create(pathstr)
            } else if (fileentry && creatEx) {
                CModule.write32(errnoPtr, KernelConstants.EEXIST)
                return ret
            }

            if (fileentry) {
                if (flags & (KernelConstants.O_WRONLY | KernelConstants.O_RDWR | KernelConstants.O_CREAT | KernelConstants.O_TRUNC) &&
                        !fileentry.writeable) {
                    CModule.write32(errnoPtr, KernelConstants.EROFS)
                    return -1
                } else if (flags & (KernelConstants.O_WRONLY | KernelConstants.O_RDWR) && fileentry.isDirectory) {
                    CModule.write32(errnoPtr, KernelConstants.EISDIR)
                    return -1
                } else if (flags & KernelConstants.O_TRUNC) {
                    fileentry.bytes.length = 0
                } else if (flags & KernelConstants.O_APPEND) {
                    fileentry.appending = true
                }
                fileentry.writeable = Boolean(flags & KernelConstants.O_WRONLY) || Boolean(flags & KernelConstants.O_RDWR)
                fileentry.readable = !(flags & KernelConstants.O_WRONLY) || (flags & KernelConstants.O_RDWR)
                ret = CModule.vfs.openFile(fileentry)
            } else {
                res = CModule.vfs.checkPath(pathstr)
                if (res == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                    CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                } else {
                    CModule.write32(errnoPtr, KernelConstants.ENOENT)
                }
                ret = -1
            }
            return ret
        }

        /**
        */
        public function close(fd:int, errnoPtr:int):int {
            if (!CModule.vfs.isValidFileDescriptor(fd)) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
                return -1
            } else {
                CModule.vfs.closeFile(fd)
            }
            return 0
        }

        /**
        */
        public function mkdir(path:int, mode:int, errnoPtr:int):int {
            var pathstr:String = readNullTerminatedStr(path)

            if (!pathstr.length) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            }

            if (CModule.vfs.getFileHandleFromPath(pathstr)) {
                CModule.write32(errnoPtr, KernelConstants.EEXIST)
                return -1
            }

            var res:String = CModule.vfs.checkPath(pathstr)

            if (res == CheckPath.PATH_COMPONENT_DOES_NOT_EXIST) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            } else if (res == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }

            var dirname:String = PathUtils.getDirectory(pathstr)
            var direntry:FileHandle = CModule.vfs.getFileHandleFromPath(dirname)
            if (!direntry.writeable) {
                CModule.write32(errnoPtr, KernelConstants.EROFS)
                return -1
            }

            CModule.vfs.addDirectory(pathstr)
            return 0
        }

        /**
        */
        private function statImpl(entry:FileHandle, ub:int, errnoPtr:int):int
        {
            // This implementation is limited to 32 bit file sizes

            var size:uint = (entry.callback || entry.isDirectory) ? 0 : entry.bytes.length
            // See STRUCT_STAT_INFO in gensyscalls.py for details on struct
            // stat offsets.

            // set st_mode
            CModule.write16(ub + 8, entry.isDirectory ? KernelConstants.S_IFDIR : ((entry.callback) ? KernelConstants.S_IFCHR : KernelConstants.S_IFREG))

            // set st_nlink
            CModule.write16(ub + 10, 1)

            // set st_size (just the lower order 32 bits)
            CModule.write32(ub + 48, size)
            
            // set st_blksize
            // 4096 bytes seems like a reasonable block size...
            CModule.write32(ub + 64, 4096)

            // set st_blocks (again, only the 32 lower order bits)
            CModule.write32(ub + 56, size / 4096 + 
                ((size % 4096 == 0) ? 0 : 1))
        
            return 0
        }

        /**
        */
        public function stat(path:int, ub:int, errnoPtr:int):int {
            var pathstr:String = readNullTerminatedStr(path)

            var res:String = CModule.vfs.checkPath(pathstr)
            if (res == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }

            var entry:FileHandle = CModule.vfs.getFileHandleFromPath(pathstr)
            if (!entry) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            } else {
                return statImpl(entry, ub, errnoPtr)
            }
        }

        /**
        */
        public function fstat(fd:int, sb:int, errnoPtr:int):int {
            var fdentry:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)
            if (!fdentry) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
                return -1
            } else {
                return statImpl(fdentry, sb, errnoPtr)
            }
        }

        /**
        */
        public function lstat(path:int, ub:int, errnoPtr:int):int {
            return stat(path, ub, errnoPtr)
        }

        /**
        * This should match the twoInts in ShellPosixGlue.cpp
        */
        private function twoInts(high:int, low:int):Array {
            return [high, low]
        }

        /**
        * Returns null on error, uint on success
        */
        private function lseekImpl(fd:int, offset:int, whence:int, 
                errnoPtr:int):* {
            var fdentry:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)
            if (!fdentry) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
                return null
            } else if (fdentry.callback) {
                CModule.write32(errnoPtr, KernelConstants.ESPIPE)
                return null
            } else {
                var pos:uint = fdentry.position
                var newpos:Number
                switch(whence) {
                case KernelConstants.SEEK_SET:
                    newpos = offset
                    break
                case KernelConstants.SEEK_CUR:
                    newpos = pos + offset
                    break
                case KernelConstants.SEEK_END:
                    newpos = fdentry.bytes.length + offset
                    break
                default:
                    CModule.write32(errnoPtr, KernelConstants.EINVAL)
                    return null
                }
                if (newpos > uint.MAX_VALUE) {
                    CModule.write32(errnoPtr, KernelConstants.EOVERFLOW)
                    return null
                } else if (newpos < 0) {
                    CModule.write32(errnoPtr, KernelConstants.EINVAL)
                    return null
                } else {
                    var setpos:uint = uint(newpos)
                    fdentry.position = setpos
                    return setpos
                }
            }

            return null
        }

        /**
        */
        public function lseek(fd:int, offset_high:int, offset_low:int, 
            whence:int, errnoPtr:int):Object {
            if (offset_high != 0 && offset_high != -1) {
              CModule.write32(errnoPtr, KernelConstants.EOVERFLOW)
              return twoInts(-1, -1)
            }
            var ret:* = lseekImpl(fd, offset_low, whence, errnoPtr)
            if (ret == null) {
                return twoInts(-1, -1)
            } else {
                return twoInts(0, ret)
            }
        }

        /**
        */
        public function rmdir(path:int, errnoPtr:int):int {
            var pathstr:String = readNullTerminatedStr(path)

            if (pathstr == "." || 
                    pathstr.substring(pathstr.length - 2) == "/.") {
                CModule.write32(errnoPtr, KernelConstants.EINVAL)
                return -1
            }

            var ent:FileHandle = CModule.vfs.getFileHandleFromPath(pathstr)

            if (ent) {
                if (ent.isDirectory) {
                    if (CModule.vfs.getDirectoryEntries(pathstr).length > 0) {
                        CModule.write32(errnoPtr, KernelConstants.ENOTEMPTY)
                        return -1
                    }
                    if (!ent.writeable) {
                        CModule.write32(errnoPtr, KernelConstants.EROFS)
                        return -1
                    }
                    CModule.vfs.deleteFile(pathstr)
                    return 0
                }
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }
            CModule.write32(errnoPtr, KernelConstants.ENOENT)
            return -1
        }

        /**
        */
        public function unlink(path:int, errnoPtr:int):int {
            var pathstr:String = readNullTerminatedStr(path)

            var res:String = CModule.vfs.checkPath(pathstr)
            if (res == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }

            var ent:FileHandle = CModule.vfs.getFileHandleFromPath(pathstr)

            if (ent) {
                if (ent.isDirectory) {
                    CModule.write32(errnoPtr, KernelConstants.EPERM)
                    return -1
                }
                if (!ent.writeable) {
                    CModule.write32(errnoPtr, KernelConstants.EROFS)
                    return -1
                }
                CModule.vfs.deleteFile(pathstr)
                return 0;
            }
            CModule.write32(errnoPtr, KernelConstants.ENOENT)
            return -1
        }

        /**
        */
        public function fcntl(fd:int, com:int, x:int, errnoPtr:int):int
    	{
            if (com == KernelConstants.F_DUPFD) {
                var fd1:int = x
                while (CModule.vfs.isValidFileDescriptor(fd1)) {
                    fd1++
                }
                return dup2(fd, fd1, errnoPtr)
            }
            var fdentry:FileHandle = getFileHandleFromFileDescriptor(fd, errnoPtr)
            if (!fdentry) {
                return -1
            }
            if (fdentry.callback) {
                return fdentry.callback.fcntl(fd, com, x, errnoPtr)
            }
            return 0
    	}

        /**
        */
        public function ioctl(fd:int, com:int, data:int, errnoPtr:int):int {
            var fdentry:FileHandle = getFileHandleFromFileDescriptor(fd, errnoPtr)
            if (!fdentry) {
                return -1
            }
            if (fdentry.callback) {
                return fdentry.callback.ioctl(fd, com, data, errnoPtr)
            }
            return 0
        }

        /**
        */
        public function getdirentries(fd:int, buf:int, nbytes:int, 
                            basep:int, errnoPtr:int):int {
            var fileentry:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)

            if(!fileentry || !fileentry.path)
                return 0

            var ba:ByteArray = new ByteArray()
            ba.endian = "littleEndian"
            var fnum:uint = 10

            var entries:Vector.<FileHandle> = CModule.vfs.getDirectoryEntries(fileentry.path)
            CModule.write32(basep, fileentry.position)
            for (var i:uint = fileentry.position; i < entries.length; i++) {
                var newp:String = entries[i].path.substr(fileentry.path.length)
                newp = newp.split(/\//)[1]
                var tlen:uint = 8 + newp.length + 1
                var plen:uint = (tlen + 3) & ~3

                if(ba.length + plen > nbytes)
                    break;

                ba.writeUnsignedInt(fnum++)
                
                ba.writeShort(plen)
                ba.writeByte(entries[i].isDirectory ? KernelConstants.DT_DIR : KernelConstants.DT_REG)
                ba.writeByte(newp.length)
                ba.writeUTFBytes(newp)
                ba.writeByte(0)
                for(var j:uint=0; j<plen-tlen; j++) {
                    ba.writeByte(0)
                }
                fileentry.position++
            }
            if(ba.length <= 0)
                return 0

            ram.position = buf
            ram.writeBytes(ba, 0, ba.length)

            return ba.length
        }

        /**
        */
        public function dup(fd:int, errnoPtr:int):int {
            var ret:int = -1;
            if (CModule.vfs.isValidFileDescriptor(fd)) {
                var ent:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)
                ret = CModule.vfs.openFile(ent)
            } else {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
            }
            return ret
        }

        /**
        */
        public function dup2(fd:int, fd2:int, errnoPtr:int):int {
            var ret:int = -1
            if (fd2 < 0) {
                CModule.write32(errnoPtr, KernelConstants.EBADF)
            } else {
                if (CModule.vfs.isValidFileDescriptor(fd)) {
                    var ent:FileHandle = CModule.vfs.getFileHandleFromFileDescriptor(fd)
                    if (CModule.vfs.isValidFileDescriptor(fd2)) {
                        CModule.vfs.closeFile(fd2)
                    }
                    ret = CModule.vfs.openFile(ent, fd2)
                } else {
                    CModule.write32(errnoPtr, KernelConstants.EBADF)
                }
            }

            return ret
        }

        /**
        */
        public function rename(old:int, newp:int, errnoPtr:int):int {
            var olds:String = readNullTerminatedStr(old)
            var news:String = readNullTerminatedStr(newp)

            if (olds.length == 0 || news.length == 0) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            }

            if (olds.charAt(olds.length - 1) == ".") {
                CModule.write32(errnoPtr, KernelConstants.EINVAL)
                return -1
            }
            olds = PathUtils.toCanonicalPath(olds)
            news = PathUtils.toCanonicalPath(news)

            if (news == olds.substr(0, news.length)) {
                CModule.write32(errnoPtr, KernelConstants.EINVAL)
                return -1
            }

            var oldCP:String = CModule.vfs.checkPath(olds)
            var newCP:String = CModule.vfs.checkPath(news)
            var oldFD:FileHandle = CModule.vfs.getFileHandleFromPath(olds)
            var newFD:FileHandle = CModule.vfs.getFileHandleFromPath(news)

            if (oldCP == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY || newCP == CheckPath.PATH_COMPONENT_IS_NOT_DIRECTORY) {
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }

            if (oldCP == CheckPath.PATH_COMPONENT_DOES_NOT_EXIST || newCP == CheckPath.PATH_COMPONENT_DOES_NOT_EXIST ||
                    !oldFD) {
                CModule.write32(errnoPtr, KernelConstants.ENOENT)
                return -1
            }

            if (newFD && newFD.isDirectory && !oldFD.isDirectory) {
                CModule.write32(errnoPtr, KernelConstants.EISDIR)
                return -1
            } else if (newFD && newFD.isDirectory && 
                    CModule.vfs.getDirectoryEntries(news).length) {
                CModule.write32(errnoPtr, KernelConstants.ENOTEMPTY)
                return -1
            } else if (oldFD.isDirectory && newFD && !newFD.isDirectory) {
                CModule.write32(errnoPtr, KernelConstants.ENOTDIR)
                return -1
            }

            var dirname:String = PathUtils.getDirectory(news)
            var direntry:FileHandle = CModule.vfs.getFileHandleFromPath(dirname)
            if (!direntry.writeable) {
                CModule.write32(errnoPtr, KernelConstants.EROFS)
                return -1
            }
    
            if (!oldFD.writeable) {
                CModule.write32(errnoPtr, KernelConstants.EROFS)
                return -1;
            }

            if (newFD) {
                CModule.vfs.deleteFile(news)
            }

            if (oldFD.isDirectory) {
                CModule.vfs.addDirectory(news)
                moveFiles(olds, news)
            } else {
                CModule.vfs.addFile(news, oldFD.bytes)
            }

            CModule.vfs.deleteFile(olds)
            return 0
        }

        /**
        */
        private function moveFiles(src:String, dst:String):void {
            var ents:Vector.<FileHandle> = CModule.vfs.getDirectoryEntries(src)
            for (var i:uint = 0; i < ents.length; i++) {
                var ent:FileHandle = ents[i]
                var newpath:String = PathUtils.toCanonicalPath(dst + '/' +
                                        ent.path.substring(src.length))
                if (ent.isDirectory) {
                    CModule.vfs.addDirectory(newpath)
                    moveFiles(ent.path, newpath)
                } else {
                    CModule.vfs.addFile(newpath, ent.bytes)
                }
                CModule.vfs.deleteFile(ent.path)
            }
        }

    	private var _ruid:int = 0
    	private var _euid:int = 0
    	private var _egid:int = 0

    	public function access(path:int, flags:int, errnoPtr:int):int
    	{
    		return 0
    	}

    	public function issetugid(errnoPtr:int):int
    	{
    		return 0
    	}

    	public function seteuid(e:int, errnoPtr:int):int
    	{
    		_euid = e
            return 0
    	}
    	
    	public function geteuid(errnoPtr:int):int
    	{
    		return _euid
    	}

    	public function setreuid(r:int, e:int, errnoPtr:int):int
    	{
    		_ruid = r
    		_euid = e
            return 0
    	}

    	public function getuid(errnoPtr:int):int
    	{
    		return _ruid
    	}

        /**
        * The default implementation always returns 42
        */
    	public function getpid(errnoPtr:int):int
    	{
    		return 42
    	}
    	
    	public function setegid(e:int, errnoPtr:int):int
    	{
    		_egid = e
            return 0
    	}

    	public function getgid(errnoPtr:int):int
    	{
    		return _egid
    	}

        public function __getcwd(buf:int, size:int, errnoPtr:int):int
        {
            CModule.write32(errnoPtr, KernelConstants.ENOSYS)
            return -1
        }

    	public function nanosleep(rqtp:int, rmtp:int, errnoPtr:int):int
    	{
    		if(workerClass)
    		{
    			var s:uint = CModule.read32(rqtp)
    			var ns:uint = CModule.read32(rqtp+4)
    			var ms:int = (s * 1000) + (ns / 1000000)
    			yield(ms)
    			if(rmtp)
    			{
                    CModule.write32(rmtp, 0)
                    CModule.write32(rmtp+4, 0)
    			}
    			return 0
    		}
            CModule.write32(errnoPtr, KernelConstants.ENOSYS)
    		return -1
    	}

    	/**
        * TODO: ignores A_clock_id, assumes a value of CLOCK_REALTIME
        */
    	public function clock_gettime(A_clock_id:int, A_tp:int, errnoPtr:int):int
    	{
    		if(A_clock_id == 0/*CLOCK_REALTIME*/)
    		{
    			var now:Date = new Date
    			CModule.write32(A_tp, now.time / 1000)
    			CModule.write32(A_tp+4, now.getMilliseconds() * 1000000)
    			return 0
    		}
    		CModule.write32(errnoPtr, KernelConstants.EINVAL)
    		return -1
    	}

    	public function sigprocmask(how:int, set:int, oset:int, errnoPtr:int):int
    	{
    		CModule.write32(errnoPtr, KernelConstants.ENOSYS)
    		return -1
    	}

        /**
        * Not implemented; always returns -1.
        */
        public function fork(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function wait4(A_pid:int, A_status:int, A_options:int, A_rusage:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function link(A_path:int, A_linkpath:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function chdir(A_path:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function fchdir(A_fd:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function chmod(A_path:int, A_mode:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function chown(A_path:int, A_uid:int, A_gid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setuid(A_uid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sync(errnoPtr:int):void{
        }
        public function kill(A_pid:int, A_signum:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getppid(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function pipe(A_fildes:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getegid(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function revoke(A_path:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function symlink(A_path:int, A_link:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function umask(A_newmask:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function chroot(A_path:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function msync(A_addr:int, A_len:int, A_flags:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function vfork(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getgroups(A_gidsetsize:int, A_gidset:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setgroups(A_gidsetsize:int, A_gidset:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getpgrp(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setpgid(A_pid:int, A_pgid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getdtablesize(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function fsync(A_fd:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setpriority(A_which:int, A_who:int, A_prio:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function socket(A_domain:int, A_type:int, A_protocol:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getpriority(A_which:int, A_who:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setsockopt(A_s:int, A_level:int, A_name:int, A_val:int, A_valsize:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function listen(A_s:int, A_backlog:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sigsuspend(A_mask:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getrusage(A_who:int, A_rusage:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getsockopt(A_s:int, A_level:int, A_name:int, A_val:int, A_avalsize:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function fchown(A_fd:int, A_uid:int, A_gid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function fchmod(A_fd:int, A_mode:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setregid(A_rgid:int, A_egid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function mkfifo(A_path:int, A_mode:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function shutdown(A_s:int, A_how:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function socketpair(A_domain:int, A_type:int, A_protocol:int, A_rsv:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setsid(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function setgid(A_gid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function pathconf(A_path:int, A_name:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function fpathconf(A_fd:int, A_name:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getpgid(A_pid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function semget(A_key:int, A_nsems:int, A_semflg:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function msgget(A_key:int, A_msgflg:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function msgsnd(A_msqid:int, A_msgp:int, A_msgsz:int, A_msgflg:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function msgrcv(A_msqid:int, A_msgp:int, A_msgsz:int, A_msgtyp:int, A_msgflg:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function shmdt(A_shmaddr:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function shmget(A_key:int, A_size:int, A_shmflg:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function lchown(A_path:int, A_uid:int, A_gid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function getsid(A_pid:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sched_yield(errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sched_get_priority_max(A_policy:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sched_get_priority_min(A_policy:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sigpending(A_set:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function sigwait(A_set:int, A_sig:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function shm_unlink(A_path:int, errnoPtr:int):int {
            return -1
        }
        /**
        * Not implemented; always returns -1.
        */
        public function pselect(A_nd:int, A_in:int, A_ou:int, A_ex:int, A_ts:int, A_sm:int, errnoPtr:int):int {
            return -1
        }
    }
}

